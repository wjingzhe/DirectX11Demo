#line 1 "C:\\Users\\Jingz\\Desktop\\DirectX11Demo\\ForwardPlus11\\src\\Shaders\\ForwardPlus11.hlsl"


#line 1 "C:\\Users\\Jingz\\Desktop\\DirectX11Demo\\ForwardPlus11\\src\\Shaders\\ForwardPlus11Common.hlsl"

cbuffer cbPerObject : register ( b0 ) 
{ 
    matrix g_mWorldViewProjection : packoffset ( c0 ) ; 
    matrix g_mWorldView : packoffset ( c4 ) ; 
    matrix g_mWorld : packoffset ( c8 ) ; 
    float4 g_MaterialAmbientColorUp : packoffset ( c12 ) ; 
    float4 g_MaterialAmbientColorDown : packoffset ( c13 ) ; 
} 

cbuffer cbPerFrame : register ( b1 ) 
{ 
    matrix g_mProjection : packoffset ( c0 ) ; 
    matrix g_mProjectionInv : packoffset ( c4 ) ; 
    float3 g_vCameraPos : packoffset ( c8 ) ; 
    float g_fAlphaTest : packoffset ( c8 . w ) ; 
    uint g_uNumLights : packoffset ( c9 . x ) ; 
    uint g_uWindowWidth : packoffset ( c9 . y ) ; 
    uint g_uWindowHeight : packoffset ( c9 . z ) ; 
    uint g_uMaxNumLightsPerTile : packoffset ( c9 . w ) ; 
} 

#line 27





#line 36
uint GetTileIndex ( float2 ScreenPos ) 
{ 
    float fTileRes = ( float ) 16 ; 
    uint uNumCellX = ( g_uWindowWidth + 16 - 1 ) / 16 ; 
    uint uTileIndex = floor ( ScreenPos . x / fTileRes ) + floor ( ScreenPos . y / fTileRes ) * uNumCellX ; 
    return uTileIndex ; 
} 

#line 5 "C:\\Users\\Jingz\\Desktop\\DirectX11Demo\\ForwardPlus11\\src\\Shaders\\ForwardPlus11.hlsl"
Texture2D g_TextureDiffuse : register ( t0 ) ; 
Texture2D g_TextureNormal : register ( t1 ) ; 
SamplerState g_Sampler : register ( s0 ) ; 

#line 11
Buffer < float4 > g_PointLightBufferCenterAndRadius : register ( t2 ) ; 
Buffer < float4 > g_PointLightBufferColor : register ( t3 ) ; 
Buffer < float4 > g_SpotLightBufferCenterAndRadius : register ( t4 ) ; 
Buffer < float4 > g_SpotLightBufferColor : register ( t5 ) ; 
Buffer < float4 > g_SpotLightBufferSpotParams : register ( t6 ) ; 
Buffer < uint > g_PerTileLightIndexBuffer : register ( t7 ) ; 

#line 23
struct VS_INPUT_SCENE 
{ 
    float3 Position : POSITION ; 
    float3 Normal : NORMAL ; 
    float2 TextureUV : TEXCOORD0 ; 
    float3 Tangent : TANGENT ; 
} ; 

struct VS_OUTPUT_SCENE 
{ 
    float4 Position : SV_POSITION ; 
    float3 Normal : NORMAL ; 
    float2 TextureUV : TEXCOORD0 ; 
    float3 Tangent : TEXCOORD1 ; 
    float4 PositionWS : TEXCOORD2 ; 
} ; 

struct VS_OUTPUT_POSITION_ONLY 
{ 
    float4 Position : SV_POSITION ; 
} ; 

#line 46
struct VS_OUTPUT_POSITION_AND_TEX 
{ 
    float4 Position : SV_POSITION ; 
    float2 TextureUV : TEXCOORD0 ; 
} ; 

#line 53
VS_OUTPUT_POSITION_ONLY RenderScenePositionOnlyVS ( VS_INPUT_SCENE Input ) 
{ 
    VS_OUTPUT_POSITION_ONLY Output ; 
    
#line 58
    Output . Position = mul ( float4 ( Input . Position , 1 ) , g_mWorldViewProjection ) ; 
    
    return Output ; 
} 

#line 67
VS_OUTPUT_POSITION_AND_TEX RenderScenePositionAndTexVS ( VS_INPUT_SCENE Input ) 
{ 
    VS_OUTPUT_POSITION_AND_TEX Output ; 
    
#line 72
    Output . Position = mul ( float4 ( Input . Position , 1 ) , g_mWorldViewProjection ) ; 
    
#line 75
    Output . TextureUV = Input . TextureUV ; 
    
    return Output ; 
} 

#line 83
VS_OUTPUT_SCENE RenderSceneVS ( VS_INPUT_SCENE Input ) 
{ 
    VS_OUTPUT_SCENE Output ; 
    
#line 88
    Output . Position = mul ( float4 ( Input . Position , 1 ) , g_mWorldViewProjection ) ; 
    
#line 91
    Output . PositionWS = mul ( float4 ( Input . Position , 1.0f ) , g_mWorld ) ; 
    Output . Normal = mul ( Input . Normal , ( float3x3 ) g_mWorld ) ; 
    Output . Tangent = mul ( Input . Tangent , ( float3x3 ) g_mWorld ) ; 
    
#line 96
    Output . TextureUV = Input . TextureUV ; 
    
    return Output ; 
    
} 

#line 105
float4 RenderSceneAlphaTestOnlyPS ( VS_OUTPUT_POSITION_AND_TEX Input ) : SV_TARGET 
{ 
    float4 DiffuseTex = g_TextureDiffuse . Sample ( g_Sampler , Input . TextureUV ) ; 
    float fAlpha = DiffuseTex . a ; 
    
    if ( fAlpha < g_fAlphaTest ) 
    { 
        discard ; 
    } 
    
    return DiffuseTex ; 
} 

#line 119
float4 RenderScenePS ( VS_OUTPUT_SCENE pin ) : SV_TARGET 
{ 
    float3 vPositionWS = pin . PositionWS . xyz ; 
    float3 AccumDiffuse = float3 ( 0 , 0 , 0 ) ; 
    float3 AccumSpecular = float3 ( 0 , 0 , 0 ) ; 
    
    float4 DiffuseTex = g_TextureDiffuse . Sample ( g_Sampler , pin . TextureUV ) ; 
    
    
    float fSpecMask = 0.0f ; 
    float fAlpha = DiffuseTex . a ; 
    if ( fAlpha < g_fAlphaTest ) 
    { 
        discard ; 
    } 
    
#line 139
    
    
#line 142
    float3 vNorm = g_TextureNormal . Sample ( g_Sampler , pin . TextureUV ) . xyz ; 
    vNorm *= 2 ; 
    vNorm -= float3 ( 1.0f , 1.0f , 1.0f ) ; 
    
#line 147
    float3 vBiNorm = normalize ( cross ( pin . Normal , pin . Tangent ) ) ; 
    float3x3 BTNMatrix = float3x3 ( vBiNorm , pin . Tangent , pin . Normal ) ; 
    vNorm = normalize ( mul ( vNorm , BTNMatrix ) ) ; 
    
    float3 vViewDir = normalize ( g_vCameraPos - vPositionWS ) ; 
    
    
    uint nTileIndex = GetTileIndex ( pin . Position . xy ) ; 
    uint nIndex = g_uMaxNumLightsPerTile * nTileIndex ; 
    uint nNextLightIndex = g_PerTileLightIndexBuffer [ nIndex ] ; 
    
#line 160
    
    
#line 163
    [ loop ] 
    
    while ( nNextLightIndex != 0x7FFFFFFF ) 
    
#line 168
    
    { 
        
        uint nLightIndex = nNextLightIndex ; 
        nIndex ++ ; 
        nNextLightIndex = g_PerTileLightIndexBuffer [ nIndex ] ; 
        
#line 176
        
        
        float4 LightCenterAndRadius = g_PointLightBufferCenterAndRadius [ nLightIndex ] ; 
        
        float3 vToLight = LightCenterAndRadius . xyz - vPositionWS . xyz ; 
        float3 vToLightDir = normalize ( vToLight ) ; 
        float fToLightDistance = length ( vToLight ) ; 
        
#line 185
        float3 LightColorDiffuse = float3 ( 0 , 0 , 0 ) ; 
        float3 LightColorSpecular = float3 ( 0 , 0 , 0 ) ; 
        
        float fRad = LightCenterAndRadius . w ; 
        
        if ( fToLightDistance < fRad ) 
        { 
            float x = fToLightDistance / fRad ; 
            
#line 198
            float fFallOff = - 0.05f + 1.05f / ( 1 + 20 * x * x ) ; 
            LightColorDiffuse = g_PointLightBufferColor [ nLightIndex ] . rgb * saturate ( dot ( vToLightDir , vNorm ) ) * fFallOff ; 
            
            float3 vHalfAngle = normalize ( vViewDir + vToLightDir ) ; 
            LightColorSpecular = g_PointLightBufferColor [ nLightIndex ] . rgb * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFallOff ; 
            
        } 
        
        AccumDiffuse += LightColorDiffuse ; 
        AccumSpecular += LightColorSpecular ; 
        
    } 
    
#line 212
    
    
    nIndex ++ ; 
    nNextLightIndex = g_PerTileLightIndexBuffer [ nIndex ] ; 
    
#line 218
    
    
#line 221
    [ loop ] 
    
    while ( nNextLightIndex != 0x7FFFFFFF ) 
    
#line 226
    
    { 
        
        
        uint nLightIndex = nNextLightIndex ; 
        nIndex ++ ; 
        nNextLightIndex = g_PerTileLightIndexBuffer [ nIndex ] ; 
        
#line 236
        
        
#line 239
        float4 BoundingSphereCenterAndRadius = g_SpotLightBufferCenterAndRadius [ nLightIndex ] ; 
        float4 SpotParams = g_SpotLightBufferSpotParams [ nLightIndex ] ; 
        
#line 244
        float3 SpotLightDir ; 
        SpotLightDir . xy = SpotParams . xy ; 
        SpotLightDir . z = sqrt ( 1 - SpotLightDir . x * SpotLightDir . x - SpotLightDir . y * SpotLightDir . y ) ; 
        
#line 249
        SpotLightDir . z = ( SpotParams . z > 0 ) ? SpotLightDir . z : - SpotLightDir . z ; 
        
#line 253
        float3 LightPosition = BoundingSphereCenterAndRadius . xyz - BoundingSphereCenterAndRadius . w * SpotLightDir ; 
        
        float3 vToLight = LightPosition . xyz - vPositionWS . xyz ; 
        float3 vToLightNormalized = normalize ( vToLight ) ; 
        float fLightDistance = length ( vToLight ) ; 
        float fCosineOfCurrentConeAngle = dot ( - vToLightNormalized , SpotLightDir ) ; 
        
        float3 LightColorDiffuse = float3 ( 0 , 0 , 0 ) ; 
        float3 LightColorSpecular = float3 ( 0 , 0 , 0 ) ; 
        
        float fRad = SpotParams . w ; 
        float fCosineOfConeAngle = ( SpotParams . z > 0 ) ? SpotParams . z : - SpotParams . z ; 
        if ( fLightDistance < fRad && fCosineOfCurrentConeAngle > fCosineOfConeAngle ) 
        { 
            float fRadialAttenuation = ( fCosineOfCurrentConeAngle - fCosineOfConeAngle ) / ( 1.0 - fCosineOfConeAngle ) ; 
            fRadialAttenuation = fRadialAttenuation * fRadialAttenuation ; 
            
            float x = fLightDistance / fRad ; 
            
#line 274
            float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
            LightColorDiffuse = g_SpotLightBufferColor [ nLightIndex ] . rgb * saturate ( dot ( vToLightNormalized , vNorm ) ) * fFalloff * fRadialAttenuation ; 
            
#line 278
            float3 vHalfAngle = normalize ( vViewDir + vToLightNormalized ) ; 
            LightColorSpecular = g_SpotLightBufferColor [ nLightIndex ] . rgb * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff * fRadialAttenuation ; 
            
        } 
        
        AccumDiffuse += LightColorDiffuse ; 
        AccumSpecular += LightColorSpecular ; 
        
    } 
    
#line 291
    AccumDiffuse *= 2 ; 
    AccumSpecular *= 8 ; 
    
#line 295
    float fAmbientBlend = 0.5f * vNorm . y + 0.5 ; 
    float3 Ambient = g_MaterialAmbientColorUp . rgb * fAmbientBlend + g_MaterialAmbientColorDown . rgb * ( 1 - fAmbientBlend ) ; 
    
#line 299
    float3 DiffuseAndAmbient = AccumDiffuse + Ambient ; 
    return float4 ( DiffuseTex . xyz * ( DiffuseAndAmbient + AccumSpecular * fSpecMask ) , 1 ) ; 
} 
 